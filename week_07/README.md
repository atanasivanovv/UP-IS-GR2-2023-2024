# Практикум #6
## Какво научихме предният път?
* структурни типове данни
* едномерни масиви
* многомерни масиви

## Какво ще научим днес?
* Бройни системи
* Two's Complement

### Броични системи

| Двоична | Осмична | Десетична | Шестнадесетична |
|---------|----------|-----------|------------------|
| 0000    | 0        | 0         | 0                |
| 0001    | 1        | 1         | 1                |
| 0010    | 2        | 2         | 2                |
| 0011    | 3        | 3         | 3                |
| 0100    | 4        | 4         | 4                |
| 0101    | 5        | 5         | 5                |
| 0110    | 6        | 6         | 6                |
| 0111    | 7        | 7         | 7                |
| 1000    | 10       | 8         | 8                |
| 1001    | 11       | 9         | 9                |
| 1010    | 12       | 10        | A                |
| 1011    | 13       | 11        | B                |
| 1100    | 14       | 12        | C                |
| 1101    | 15       | 13        | D                |
| 1110    | 16       | 14        | E                |
| 1111    | 17       | 15        | F                |


### Two's Complement

Двоичният допълнителен код (Two's Complement) е начин за представяне на отрицателни числа в двоична бройна система. Този метод позволява просто и ефективно представяне на цели числа в компютърните системи.

В двоичния допълнителен код, отрицателните числа се представят чрез инвертиране на всички битове на положителното число и след това се добавя 1. Този процес прави аритметиката на компютърите по-лесна, тъй като събирането на двоични числа и увеличаването на едно число се извършват по един и същ начин.

Пример:
Нека разгледаме числото -5 в двоичен допълнителен код с 8 бита:

Представяне на 5 в двоична бройна система:

- Десетично: 5
    - Двоично: 00000101
    - Инвертиране на всички битове:

- 00000101 става 11111010
    - Добавяне на 1:

- 11111010 + 1 = 11111011

Така получаваме представянето на -5 в двоичен допълнителен код с 8 бита.

### Памет (Memory)
Паметта е поредица от клетки, всяка от които има свой размер и адрес. Когато казваме *колко клетки("променливи") да се заделят в паметта*, имаме предвид че, в паметта трябва да има толкова свободни клетки, със съответния размер на типа на масива(променливите от този тип), колкото ние сме посочили, че да може да заемем. Например, aко пазим работните часове на 100 работника, в паметта масивът ни ще изглежда като на картинката горе. 


#### Паметта, която можете да използвате в C++ програма е най-общо казано три типа:
* статична

в тази памет се записват променливите, обявени извън функциите (т.нар. глобални променливи). Те се виждат от всички функции през цялото изпълнение на програмата
* стекова

в тази памет се записват предадените параметри и променливите дефинирани вътре във функциите и въобще в произволен блок. Променливите се виждат само във функцията (блока) в която са дефинирани и се унищожават при завършване на функцията (излизане от блока)
* динамична

останалата част от паметта на компютърна е достъпна до всички програми при поискване. За управлението на тази памет се грижи операционната система  . Във всеки момент отделен блок от паметта може да е свободен или да е заделен за някоя програма, при която може да го чете само тя. При опит някоя програма да прочете памет, която не е заделена за нея, независимо дали е заделена за друга програма или е свободна, операционната система прекратява изпълнението на програмат с грешка Access Violation

### sizeof()
Sizeof е оператор, който ни показва колко памет(в байтове) заема дадена променлива от съответен тип. 
```c++
#include <iostream>
using namespace std;

int main()
{
    cout << "bool:\t" << sizeof(bool) << " bytes" << endl;
    cout << "char:\t" << sizeof(char) << " bytes" << endl;
    cout << "short:\t" << sizeof(short) << " bytes" << endl;
    cout << "int:\t" << sizeof(int) << " bytes" << endl;
    cout << "long:\t" << sizeof(long) << " bytes" << endl;
    cout << "float:\t" << sizeof(float) << " bytes" << endl;
    cout << "double:\t" << sizeof(double) << " bytes" << endl;
    cout << "long double:\t" << sizeof(long double) << " bytes" << endl;
    
    return 0;
}
    
```

	bool:		1 bytes
	char:		1 bytes
	short:		2 bytes
	int:		4 bytes
	long:		8 bytes
	float:		4 bytes
	double:		8 bytes
	long double: 	16 bytes

Когато използваме sizeof() върху масив, отново получаваме размера в байтове. Например, ако масива ни е от тип char и е с големина 100 елемента, то неговият размер е 100 елемента * 1 байт = 100 байта.
```c++
#include <iostream>
using namespace std;

int main()
{
    int arr[100];
    char str[100];
	
    cout << sizeof(arr) << " bytes" << endl;
    cout << sizeof(str) << " bytes" << endl;
    
    return 0;
}
```

